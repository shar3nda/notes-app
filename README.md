# Приложение для заметок

[![CI/CD](https://github.com/shar3nda/notes-app/actions/workflows/ci.yml/badge.svg)](https://github.com/shar3nda/notes-app/actions/workflows/ci.yml)

## Пререквизиты

- Python 3.12
- Node.js 22
- Docker

## Установка

```sh
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt

cd frontend
npm install
```

## Запуск бэкенда

### Локально

```sh
export RUN_MODE=dev
dev/start-db.sh
alembic upgrade head
python3 -m src.scripts.seed
```

```sh
export RUN_MODE=dev
uvicorn src.main:app --reload --log-config src/log_conf.yaml
```

### Локально - Docker Compose

```sh
export RUN_MODE=dev
docker compose up -d --build
alembic upgrade head
python3 -m src.scripts.seed
```

## Запуск фронтэнда

```sh
cd frontend
npm run dev
```

Тестовый пользователь:

`user1`

`password1`

## Выполненные задания

### 4 Балла (За каждый пункт 4/<кол-во пунктов> баллов)

1. Приложение поддерживает аутентификацию пользователей и контроль доступа к API.

Да, поддерживается аутентификация OAuth2 с использованием JWT-токенов с refresh'ем.
Регистрироваться и входить может любой, управлять заметками - только залогиненный
пользователь. Также, можно просматривать и управлять только свои заметки.

2. Приложение имеет gRPC или HTTP API (минимум четыре бизнес-метода: создание,
получение, изменение, удаление).

Да, приложение использует HTTP REST API. Поддерживаются CRUD-операции для заметок
(получить одну, получить все с кратким текстом, новая, обновить, удалить).

3. Все сервисы и API покрыты тестами (unit и функциональными).

Частично - реализованы функциональные тесты для ручек API на аутентификацию.

4. Приложение использует внешнюю БД для хранения пользователей и бизнес-
информации.

Да - используется PostgreSQL, работающий в контейнере, с сохранением данных в
именованный volume.

5. Схема базы данных создаётся при запуске или деплое приложения, поддерживается
версионирование схемы.

Да - для описания схемы используется SQLModel, для создания и применения миграций -
Alembic. При работе в Kubernetes в init-контейнере запускается применение миграций, и при
ошибке применения (несоответствие схемы) приложение не запустится.

6. Схема базы данных отражается в код при сборке. Несоответствие ORM-моделей,
запросов и схемы приводит к ошибке сборки

Да - проверка схем на бэкенде реализована с помощью валидации FastAPI и Pydantic.
Интерфейсы для фронтэнда на TypeScript генерируются с помощью `openapi-ts`; компилятор
TypeScript завершит работу с ошибкой при некорректном использовании типов. В CI также
встроена проверка на соответствие схем и миграций.

### 4 Балла (За каждый пункт 4/<кол-во пунктов> баллов)

1. Приложение поддерживает логирование.

Да - приложение использует логирование. Используется единый формат логов.

2. Приложение поддерживает метрики.

Нет - собственные метрики приложения не реализованы.

3. Приложение может быть запущено в Kubernetes (приложение, БД, логирование,
балансировщик и сервис).

Да - приложение запускается в Kubernetes в трех разных Deployment - API, фронтенд и БД.
К каждому компоненту прилагается сервис ClusterIP, а фронт и бэк открыты для доступа
снаружи кластера с помощью Ingress.

4. Поддерживается сборка логов приложения и всех взаимодействующих с приложением
инфраструктурных объектов в Kubernetes.

Да - реализована сборка логов приложения с помощью Loki и Alloy; логи можно просматривать
и искать в дашборде Grafana.

## 2 Балла (За каждый пункт 2/<кол-во пунктов> баллов)

1. Каждый коммит в мастер-ветку собирается при помощи CI/CD системы. В случае
ошибочной сборки об этом сигнализируется каким-либо образом (плашка на GitHub,
нотификация в чат-бот).

Да - для проекта настроен пайплайн Github Actions на каждый коммит.

**CI**

- Установка зависимостей
- Проверка качества кода линтером
- Проверка сгенерированного кода
- Запуск приложения в Docker Compose
- Проверка миграций
- Запуск автотестов
- Сборка образов Docker и публикация в реестр GHCR

**CD**

- Загрузка секретов (kubeconfig, пользователь/пароль PostgreSQL, секрет OAuth2) из
Repository Secrets
- Установка kubectl и загрузка kubeconfig
- Применение манифестов с подстановкой переменных через Jinja

При неудачном прохождении какого-либо этапа пайплайн завершается. Также, высвечивается
результат в виде плашки в начале README.

2. По всем API-методам есть Swagger-документация, доступная из приложения.

Да, документация Swagger генерируется автоматически и доступна по пути `/docs`.
